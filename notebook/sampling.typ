= Sparse sampling notes (IR): symmetry, point selection, and natural weights

This note summarizes a practical sampling scheme for fitting IR coefficients from samples on a 1D domain (e.g. $t in [0,1]$ for $tau/beta$), with special emphasis on the *centrosymmetric* structure of IR basis functions.

The guiding idea is:

- We fit IR coefficients using a design matrix built from IR basis functions evaluated at sampling points.
- If the basis has a known mirror-sign relation, then sampling points naturally come in mirror pairs and the problem splits into even/odd subproblems.
- Candidate points can be generated by heuristics (kernel hints + Gauss–Legendre segments), but the scheme is not limited to those candidates.
- Given *any* candidate point set, a natural set of weights is obtained by the nearest-neighbor (Voronoi) partition of the domain.

== 1. Setup: IR fitting from samples

Let $U_l(t)$ be IR basis functions on $t in [0,1]$ (with $t = tau/beta$). Fix an IR truncation size $N_l$.

We want to fit coefficients $g_l$ from sampled values $G(t)$ via

$ G(t) approx sum_(l=0)^(N_l-1) g_l U_l(t). $

Given sampling points $t_j$ (for $j=1..k$), define the design matrix

$ A_(j,l) = U_l(t_j) $,

so that

$ A g approx y, \; y_j = G(t_j). $

A stable sampling set is one for which $A$ has full column rank and a moderate condition number.

== 2. Centrosymmetry of the IR basis: mirror points and sign

Assume the basis has the mirror-sign property

$ U_l(1 - t) = (-1)^l U_l(t). $

This is the key structural fact.

Let the mirror map on points be

$ m(t) = 1 - t. $

Then sampling at both $t$ and $m(t)$ is natural.

Define index sets `E` and `O` as the even/odd IR indices in `0..N_l-1`.

=== 2.1 Even/odd decoupling by sum/difference

For any $t$, define

- $G_+(t) = G(t) + G(1-t)$,
- $G_-(t) = G(t) - G(1-t)$.

Using $U_l(1-t)=(-1)^l U_l(t)$, we obtain

$ G_+(t) approx 2 sum_(l in E) g_l U_l(t), $

$ G_-(t) approx 2 sum_(l in O) g_l U_l(t). $

So the fitting problem splits into two independent subproblems (even-$l$ and odd-$l$).

=== 2.2 Why representatives are about half: a dimension-count argument

If we enforce mirror pairing, the total number of sampled points is approximately

$ k approx 2 k_("rep") $,

where $k_("rep")$ is the number of representative points on (say) $t in [0,1/2]$.

To determine $N_l$ coefficients in general we need at least $k >= N_l$ independent equations. Under pairing this implies

$ 2 k_("rep") >= N_l \;⇒\; k_("rep") >= ceil(N_l / 2). $

More precisely, the even and odd blocks have sizes

- $N_("even")$ = the number of even indices $l < N_l$,
- $N_("odd")$  = the number of odd indices $l < N_l$,

and the two decoupled fits require

$ k_("rep") >= max(N_("even"), N_("odd")) approx N_l/2. $

This explains why selecting about half as many representatives is the natural baseline.

== 3. Selecting representative points

Let $T$ be a candidate set of points in $[0,1]$.

In practice we typically work with representatives on $[0,1/2]$ and then mirror them.

=== 3.1 Candidate generation (recommended, but not required)

A good way to produce candidates is a heuristic mesh such as:

- kernel hints (regions where basis/kernel varies rapidly), plus
- piecewise Gauss–Legendre nodes within segments.

This often yields a compact and high-quality candidate set.

However, the selection scheme does *not* depend on this choice.

=== 3.2 General input: any candidate points are acceptable

If the user provides an arbitrary candidate set (possibly nonuniform, irregular, or adaptive), we can still proceed.

The only requirements are:

- points lie within the domain (e.g. $[0,1]$),
- points are distinct after deduplication,
- and we can evaluate $U_l(t)$ on them.

== 4. Natural weights from a nearest-neighbor partition

When candidates are nonuniform, it is natural to assign a weight to each point reflecting the portion of the domain it represents.

Given *any* sorted candidate set

$ 0 <= t_0 < t_1 < ... < t_(N-1) <= 1, $

a natural partition is the nearest-neighbor (Voronoi) partition on $[0,1]$.

Each point $t_i$ owns the interval of locations closer to $t_i$ than to any other point.
The length of that cell provides the weight.

In 1D this yields the simple formula

- interior: $w_i = (t_(i+1) - t_(i-1)) / 2$,
- endpoints: $w_0 = t_1 - t_0$, $w_(N-1) = t_(N-1) - t_(N-2)$.

These weights satisfy $sum_i w_i approx 1$ and behave well for log-like meshes.

=== 4.1 Using weights in point selection

Weights can be incorporated by scaling rows of the design matrix.
If $A_(j,l) = U_l(t_j)$ and $w_j$ are weights, define

$ A_w_(j,l) = sqrt(w_j) A_(j,l). $

Then selecting points to improve the conditioning of $A_w$ corresponds to a weighted inner product on the domain.

== 5. A practical workflow

1. *Input candidates*: start from a candidate set $T$.
   - Recommended: hint + Gauss–Legendre segmented mesh.
   - Allowed: any user-provided points.

2. *Compute weights*: build nearest-neighbor (Voronoi) cell-width weights on the domain.

3. *Restrict to representatives* (if using mirror symmetry): keep a representative subset `T_rep`, e.g. points in `[0, 1/2]`.
   - If $t=1/2$ is present (fixed point), treat it as its own mirror.

4. *Select representatives*: pick `k_rep` points to make the (weighted) design matrix well-conditioned.
   - Minimal baseline: $k_("rep") approx N_l/2$.
   - Practical robustness: slightly more, e.g. $k approx 1.2 N_l$ total implies $k_("rep") approx 0.6 N_l$.

5. *Mirror*: form the full symmetric sampling set

- `S = S_rep ∪ (1 - S_rep)`.

== 6. Notes

- This document focused on the IR-basis matrix $U_l(t)$.
  The same philosophy applies to Matsubara sampling, except that the “domain” is a discrete set of Matsubara indices and the symmetry is $nu -> -nu$.

== 6. Matsubara domain: candidates, pairing, and a natural partition

In Matsubara space the sampling variable is discrete. For fermions,

- $nu_n = (2n+1) pi / beta$, for $n = 0,1,2,...$

and for bosons,

- $nu_n = 2n pi / beta$, for $n = 0,1,2,...$.

It is convenient to work with a dimensionless frequency

$ u_n = nu_n / omega_(\"max\") $,

so that

- fermion: $u_n = (2n+1) pi / Lambda$,
- boson:   $u_n = 2n pi / Lambda$,

where $Lambda = beta omega_(\"max\")$.

=== 6.1 ± pairing and avoiding complex arithmetic

If you want the sampling set to be symmetric under $nu -> -nu$, select only *positive* representatives and then add their negatives.
This is justified whenever the sampled object satisfies the conjugacy relation

$ G(-i nu) = overline(G(i nu)). $

To avoid complex arithmetic in the selection step, build a real feature/design matrix by stacking real/imag parts.
For example, for a complex feature matrix $F(i nu_n) in CC^(k times N_l)$ you can run selection on

- `F_even = Re(F)`,
- `F_odd  = Im(F)`,
- `A = vcat(alpha * F_even, beta * F_odd)`.

=== 6.2 Candidate generation on Matsubara (log-like)

Uniform sampling in $n$ (or in $|nu|$) is often wasteful. A practical approach is to generate a log-like candidate set on the *positive* axis.
Implementation-wise the candidates are still integers $n$.

One simple recipe:

- choose a set of target magnitudes in $u$ on a log grid up to $u_(\"max\")$,
- map each target to the nearest integer index $n$,
- deduplicate the resulting indices,
- then mirror to obtain ± pairs if desired.

=== 6.3 A natural “partition weight” for discrete Matsubara candidates

Even though Matsubara is discrete, if you generate *nonuniform* candidates it is still useful to assign a weight reflecting the spacing.

Given a sorted candidate set on the positive axis

$ 0 <= u_0 < u_1 < ... < u_(N-1), $

define the 1D Voronoi (nearest-neighbor) cell-width weights in $u$ by

- interior: $w_i = (u_(i+1) - u_(i-1)) / 2$,
- endpoints: $w_0 = u_1 - u_0$, $w_(N-1) = u_(N-1) - u_(N-2)$.

These weights are natural when you think of the candidate set as representing a nonuniform discretization of a continuous variable $u$.

If you then expand to ± pairs, a convenient symmetric choice is

- for each positive representative $u_i$: use the same weight for $+u_i$ and $-u_i$,
- for a fixed point (bosonic $nu=0$): treat it as its own mirror and handle carefully if any weight construction would make it vanish.

- If the mirror-sign relation holds exactly, “pair-lifting” to a $2N_l$-row matrix is typically redundant for selection; selecting representatives and mirroring is sufficient.
