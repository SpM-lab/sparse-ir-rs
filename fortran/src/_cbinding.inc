! Autogenerated Fortran interfaces for ../sparse-ir-capi/include/sparseir/sparseir.h
subroutine c_spir_basis_release( &
    & basis) &
    bind(c, name="spir_basis_release")
  import :: c_ptr
  type(c_ptr), value :: basis
end subroutine

function c_spir_basis_clone( &
    & src) &
    bind(c, name="spir_basis_clone")
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_basis_clone

end function

function c_spir_basis_is_assigned( &
    & obj) &
    bind(c, name="spir_basis_is_assigned")
  import :: c_int, c_ptr
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_basis_is_assigned

end function

function c_spir_basis_new( &
    & statistics, beta, omega_max, epsilon, k, sve, max_size, status) &
    bind(c, name="spir_basis_new")
  import :: c_double, c_int, c_ptr
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  real(c_double), value :: epsilon
  type(c_ptr), value :: k
  type(c_ptr), value :: sve
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_new

end function

function c_spir_basis_new_from_sve_and_inv_weight( &
    & statistics, beta, omega_max, epsilon, lambda, f__ypower, f__conv_radius, sve, &
    & inv_weight_funcs, max_size, status) &
    bind(c, name="spir_basis_new_from_sve_and_inv_weight")
  import :: c_double, c_int, c_ptr
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  real(c_double), value :: epsilon
  real(c_double), value :: lambda
  integer(c_int), value :: f__ypower
  real(c_double), value :: f__conv_radius
  type(c_ptr), value :: sve
  type(c_ptr), value :: inv_weight_funcs
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_new_from_sve_and_inv_weight

end function

function c_spir_basis_get_size( &
    & b, size) &
    bind(c, name="spir_basis_get_size")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_basis_get_size

end function

function c_spir_basis_get_svals( &
    & b, svals) &
    bind(c, name="spir_basis_get_svals")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_basis_get_svals

end function

function c_spir_basis_get_stats( &
    & b, statistics) &
    bind(c, name="spir_basis_get_stats")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: statistics
  integer(c_int) :: c_spir_basis_get_stats

end function

function c_spir_basis_get_singular_values( &
    & b, svals) &
    bind(c, name="spir_basis_get_singular_values")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_basis_get_singular_values

end function

function c_spir_basis_get_n_default_taus( &
    & b, num_points) &
    bind(c, name="spir_basis_get_n_default_taus")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_taus

end function

function c_spir_basis_get_default_taus( &
    & b, points) &
    bind(c, name="spir_basis_get_default_taus")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_taus

end function

function c_spir_basis_get_n_default_matsus( &
    & b, positive_only, num_points) &
    bind(c, name="spir_basis_get_n_default_matsus")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_matsus

end function

function c_spir_basis_get_default_matsus( &
    & b, positive_only, points) &
    bind(c, name="spir_basis_get_default_matsus")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_matsus

end function

function c_spir_basis_get_u( &
    & b, status) &
    bind(c, name="spir_basis_get_u")
  import :: c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_u

end function

function c_spir_basis_get_v( &
    & b, status) &
    bind(c, name="spir_basis_get_v")
  import :: c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_v

end function

function c_spir_basis_get_n_default_ws( &
    & b, num_points) &
    bind(c, name="spir_basis_get_n_default_ws")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_ws

end function

function c_spir_basis_get_default_ws( &
    & b, points) &
    bind(c, name="spir_basis_get_default_ws")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_ws

end function

function c_spir_basis_get_uhat( &
    & b, status) &
    bind(c, name="spir_basis_get_uhat")
  import :: c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_uhat

end function

function c_spir_basis_get_uhat_full( &
    & b, status) &
    bind(c, name="spir_basis_get_uhat_full")
  import :: c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_uhat_full

end function

function c_spir_basis_get_default_taus_ext( &
    & b, n_points, points, n_points_returned) &
    bind(c, name="spir_basis_get_default_taus_ext")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_basis_get_default_taus_ext

end function

function c_spir_basis_get_n_default_matsus_ext( &
    & b, positive_only, L, num_points_returned) &
    bind(c, name="spir_basis_get_n_default_matsus_ext")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: L
  type(c_ptr), value :: num_points_returned
  integer(c_int) :: c_spir_basis_get_n_default_matsus_ext

end function

function c_spir_basis_get_default_matsus_ext( &
    & b, positive_only, mitigate, n_points, points, n_points_returned) &
    bind(c, name="spir_basis_get_default_matsus_ext")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: mitigate
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_basis_get_default_matsus_ext

end function

function c_spir_dlr_new( &
    & b, status) &
    bind(c, name="spir_dlr_new")
  import :: c_ptr
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_dlr_new

end function

function c_spir_dlr_new_with_poles( &
    & b, npoles, poles, status) &
    bind(c, name="spir_dlr_new_with_poles")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: npoles
  type(c_ptr), value :: poles
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_dlr_new_with_poles

end function

function c_spir_dlr_get_npoles( &
    & dlr, num_poles) &
    bind(c, name="spir_dlr_get_npoles")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: num_poles
  integer(c_int) :: c_spir_dlr_get_npoles

end function

function c_spir_dlr_get_poles( &
    & dlr, poles) &
    bind(c, name="spir_dlr_get_poles")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: poles
  integer(c_int) :: c_spir_dlr_get_poles

end function

function c_spir_ir2dlr_dd( &
    & dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_dd")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_ir2dlr_dd

end function

function c_spir_ir2dlr_zz( &
    & dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_zz")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_ir2dlr_zz

end function

function c_spir_dlr2ir_dd( &
    & dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_dd")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_dlr2ir_dd

end function

function c_spir_dlr2ir_zz( &
    & dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_zz")
  import :: c_int, c_ptr
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_dlr2ir_zz

end function

subroutine c_spir_funcs_release( &
    & funcs) &
    bind(c, name="spir_funcs_release")
  import :: c_ptr
  type(c_ptr), value :: funcs
end subroutine

function c_spir_funcs_clone( &
    & src) &
    bind(c, name="spir_funcs_clone")
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_funcs_clone

end function

function c_spir_funcs_is_assigned( &
    & obj) &
    bind(c, name="spir_funcs_is_assigned")
  import :: c_int, c_ptr
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_funcs_is_assigned

end function

function c_spir_funcs_from_piecewise_legendre( &
    & segments, n_segments, coeffs, nfuncs, f__order, status) &
    bind(c, name="spir_funcs_from_piecewise_legendre")
  import :: c_int, c_ptr
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: coeffs
  integer(c_int), value :: nfuncs
  integer(c_int), value :: f__order
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_funcs_from_piecewise_legendre

end function

function c_spir_funcs_get_slice( &
    & funcs, nslice, indices, status) &
    bind(c, name="spir_funcs_get_slice")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  integer(c_int), value :: nslice
  type(c_ptr), value :: indices
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_funcs_get_slice

end function

function c_spir_funcs_get_size( &
    & funcs, size) &
    bind(c, name="spir_funcs_get_size")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_funcs_get_size

end function

function c_spir_funcs_get_n_knots( &
    & funcs, n_knots) &
    bind(c, name="spir_funcs_get_n_knots")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  type(c_ptr), value :: n_knots
  integer(c_int) :: c_spir_funcs_get_n_knots

end function

function c_spir_funcs_get_knots( &
    & funcs, knots) &
    bind(c, name="spir_funcs_get_knots")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  type(c_ptr), value :: knots
  integer(c_int) :: c_spir_funcs_get_knots

end function

function c_spir_funcs_eval( &
    & funcs, x, out) &
    bind(c, name="spir_funcs_eval")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: funcs
  real(c_double), value :: x
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_eval

end function

function c_spir_funcs_eval_matsu( &
    & funcs, n, out) &
    bind(c, name="spir_funcs_eval_matsu")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  integer(c_int), value :: n
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_eval_matsu

end function

function c_spir_funcs_batch_eval( &
    & funcs, order, num_points, xs, out) &
    bind(c, name="spir_funcs_batch_eval")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_points
  type(c_ptr), value :: xs
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_batch_eval

end function

function c_spir_funcs_batch_eval_matsu( &
    & funcs, order, num_freqs, ns, out) &
    bind(c, name="spir_funcs_batch_eval_matsu")
  import :: c_int, c_ptr
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_freqs
  type(c_ptr), value :: ns
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_batch_eval_matsu

end function

function c_spir_uhat_get_default_matsus( &
    & uhat, l, positive_only, mitigate, points, n_points_returned) &
    bind(c, name="spir_uhat_get_default_matsus")
  import :: c_int, c_ptr
  type(c_ptr), value :: uhat
  integer(c_int), value :: l
  integer(c_int), value :: positive_only
  integer(c_int), value :: mitigate
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_uhat_get_default_matsus

end function

function c_spir_gemm_backend_new_from_fblas_lp64( &
    & dgemm, zgemm) &
    bind(c, name="spir_gemm_backend_new_from_fblas_lp64")
  import :: c_ptr
  type(c_ptr), value :: dgemm
  type(c_ptr), value :: zgemm
  type(c_ptr) :: c_spir_gemm_backend_new_from_fblas_lp64

end function

function c_spir_gemm_backend_new_from_fblas_ilp64( &
    & dgemm64, zgemm64) &
    bind(c, name="spir_gemm_backend_new_from_fblas_ilp64")
  import :: c_ptr
  type(c_ptr), value :: dgemm64
  type(c_ptr), value :: zgemm64
  type(c_ptr) :: c_spir_gemm_backend_new_from_fblas_ilp64

end function

subroutine c_spir_gemm_backend_release( &
    & backend) &
    bind(c, name="spir_gemm_backend_release")
  import :: c_ptr
  type(c_ptr), value :: backend
end subroutine

function c_spir_logistic_kernel_new( &
    & lambda, status) &
    bind(c, name="spir_logistic_kernel_new")
  import :: c_double, c_ptr
  real(c_double), value :: lambda
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_logistic_kernel_new

end function

function c_spir_reg_bose_kernel_new( &
    & lambda, status) &
    bind(c, name="spir_reg_bose_kernel_new")
  import :: c_double, c_ptr
  real(c_double), value :: lambda
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_reg_bose_kernel_new

end function

function c_spir_kernel_get_lambda( &
    & kernel, lambda_out) &
    bind(c, name="spir_kernel_get_lambda")
  import :: c_int, c_ptr
  type(c_ptr), value :: kernel
  type(c_ptr), value :: lambda_out
  integer(c_int) :: c_spir_kernel_get_lambda

end function

function c_spir_kernel_compute( &
    & kernel, x, y, out) &
    bind(c, name="spir_kernel_compute")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: kernel
  real(c_double), value :: x
  real(c_double), value :: y
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_kernel_compute

end function

subroutine c_spir_kernel_release( &
    & kernel) &
    bind(c, name="spir_kernel_release")
  import :: c_ptr
  type(c_ptr), value :: kernel
end subroutine

function c_spir_kernel_clone( &
    & src) &
    bind(c, name="spir_kernel_clone")
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_kernel_clone

end function

function c_spir_kernel_is_assigned( &
    & obj) &
    bind(c, name="spir_kernel_is_assigned")
  import :: c_int, c_ptr
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_kernel_is_assigned

end function

function c_spir_kernel_get_domain( &
    & k, xmin, xmax, ymin, ymax) &
    bind(c, name="spir_kernel_get_domain")
  import :: c_int, c_ptr
  type(c_ptr), value :: k
  type(c_ptr), value :: xmin
  type(c_ptr), value :: xmax
  type(c_ptr), value :: ymin
  type(c_ptr), value :: ymax
  integer(c_int) :: c_spir_kernel_get_domain

end function

function c_spir_kernel_get_sve_hints_segments_x( &
    & k, epsilon, segments, n_segments) &
    bind(c, name="spir_kernel_get_sve_hints_segments_x")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: segments
  type(c_ptr), value :: n_segments
  integer(c_int) :: c_spir_kernel_get_sve_hints_segments_x

end function

function c_spir_kernel_get_sve_hints_segments_y( &
    & k, epsilon, segments, n_segments) &
    bind(c, name="spir_kernel_get_sve_hints_segments_y")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: segments
  type(c_ptr), value :: n_segments
  integer(c_int) :: c_spir_kernel_get_sve_hints_segments_y

end function

function c_spir_kernel_get_sve_hints_nsvals( &
    & k, epsilon, nsvals) &
    bind(c, name="spir_kernel_get_sve_hints_nsvals")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: nsvals
  integer(c_int) :: c_spir_kernel_get_sve_hints_nsvals

end function

function c_spir_kernel_get_sve_hints_ngauss( &
    & k, epsilon, ngauss) &
    bind(c, name="spir_kernel_get_sve_hints_ngauss")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: ngauss
  integer(c_int) :: c_spir_kernel_get_sve_hints_ngauss

end function

subroutine c_spir_sampling_release( &
    & sampling) &
    bind(c, name="spir_sampling_release")
  import :: c_ptr
  type(c_ptr), value :: sampling
end subroutine

function c_spir_sampling_clone( &
    & src) &
    bind(c, name="spir_sampling_clone")
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_sampling_clone

end function

function c_spir_sampling_is_assigned( &
    & obj) &
    bind(c, name="spir_sampling_is_assigned")
  import :: c_int, c_ptr
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_sampling_is_assigned

end function

function c_spir_tau_sampling_new( &
    & b, num_points, points, status) &
    bind(c, name="spir_tau_sampling_new")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_tau_sampling_new

end function

function c_spir_matsu_sampling_new( &
    & b, positive_only, num_points, points, status) &
    bind(c, name="spir_matsu_sampling_new")
  import :: c_int, c_ptr
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_matsu_sampling_new

end function

function c_spir_tau_sampling_new_with_matrix( &
    & order, statistics, basis_size, num_points, points, matrix, status) &
    bind(c, name="spir_tau_sampling_new_with_matrix")
  import :: c_int, c_ptr
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_tau_sampling_new_with_matrix

end function

function c_spir_matsu_sampling_new_with_matrix( &
    & order, statistics, basis_size, positive_only, num_points, points, matrix, status) &
    bind(c, name="spir_matsu_sampling_new_with_matrix")
  import :: c_int, c_ptr
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_matsu_sampling_new_with_matrix

end function

function c_spir_sampling_get_npoints( &
    & s, num_points) &
    bind(c, name="spir_sampling_get_npoints")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_sampling_get_npoints

end function

function c_spir_sampling_get_taus( &
    & s, points) &
    bind(c, name="spir_sampling_get_taus")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_sampling_get_taus

end function

function c_spir_sampling_get_matsus( &
    & s, points) &
    bind(c, name="spir_sampling_get_matsus")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_sampling_get_matsus

end function

function c_spir_sampling_get_cond_num( &
    & s, cond_num) &
    bind(c, name="spir_sampling_get_cond_num")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: cond_num
  integer(c_int) :: c_spir_sampling_get_cond_num

end function

function c_spir_sampling_eval_dd( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dd")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_dd

end function

function c_spir_sampling_eval_dz( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dz")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_dz

end function

function c_spir_sampling_eval_zz( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_zz")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_zz

end function

function c_spir_sampling_fit_dd( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_dd")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_dd

end function

function c_spir_sampling_fit_zz( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_zz")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_zz

end function

function c_spir_sampling_fit_zd( &
    & s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_zd")
  import :: c_int, c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_zd

end function

subroutine c_spir_sve_result_release( &
    & sve) &
    bind(c, name="spir_sve_result_release")
  import :: c_ptr
  type(c_ptr), value :: sve
end subroutine

function c_spir_sve_result_clone( &
    & src) &
    bind(c, name="spir_sve_result_clone")
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_sve_result_clone

end function

function c_spir_sve_result_is_assigned( &
    & obj) &
    bind(c, name="spir_sve_result_is_assigned")
  import :: c_int, c_ptr
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_sve_result_is_assigned

end function

function c_spir_sve_result_new( &
    & k, epsilon, f__lmax, f__n_gauss, twork, status) &
    bind(c, name="spir_sve_result_new")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  integer(c_int), value :: f__lmax
  integer(c_int), value :: f__n_gauss
  integer(c_int), value :: twork
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_new

end function

function c_spir_sve_result_get_size( &
    & sve, size) &
    bind(c, name="spir_sve_result_get_size")
  import :: c_int, c_ptr
  type(c_ptr), value :: sve
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_sve_result_get_size

end function

function c_spir_sve_result_truncate( &
    & sve, epsilon, max_size, status) &
    bind(c, name="spir_sve_result_truncate")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: sve
  real(c_double), value :: epsilon
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_truncate

end function

function c_spir_sve_result_get_svals( &
    & sve, svals) &
    bind(c, name="spir_sve_result_get_svals")
  import :: c_int, c_ptr
  type(c_ptr), value :: sve
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_sve_result_get_svals

end function

function c_spir_sve_result_from_matrix( &
    & K_high, K_low, nx, ny, order, segments_x, n_segments_x, segments_y, n_segments_y, &
    & n_gauss, epsilon, status) &
    bind(c, name="spir_sve_result_from_matrix")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: K_high
  type(c_ptr), value :: K_low
  integer(c_int), value :: nx
  integer(c_int), value :: ny
  integer(c_int), value :: order
  type(c_ptr), value :: segments_x
  integer(c_int), value :: n_segments_x
  type(c_ptr), value :: segments_y
  integer(c_int), value :: n_segments_y
  integer(c_int), value :: n_gauss
  real(c_double), value :: epsilon
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_from_matrix

end function

function c_spir_sve_result_from_matrix_centrosymmetric( &
    & K_even_high, K_even_low, K_odd_high, K_odd_low, nx, ny, order, segments_x, &
    & n_segments_x, segments_y, n_segments_y, n_gauss, epsilon, status) &
    bind(c, name="spir_sve_result_from_matrix_centrosymmetric")
  import :: c_double, c_int, c_ptr
  type(c_ptr), value :: K_even_high
  type(c_ptr), value :: K_even_low
  type(c_ptr), value :: K_odd_high
  type(c_ptr), value :: K_odd_low
  integer(c_int), value :: nx
  integer(c_int), value :: ny
  integer(c_int), value :: order
  type(c_ptr), value :: segments_x
  integer(c_int), value :: n_segments_x
  type(c_ptr), value :: segments_y
  integer(c_int), value :: n_segments_y
  integer(c_int), value :: n_gauss
  real(c_double), value :: epsilon
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_from_matrix_centrosymmetric

end function

function c_spir_choose_working_type( &
    & epsilon) &
    bind(c, name="spir_choose_working_type")
  import :: c_double, c_int
  real(c_double), value :: epsilon
  integer(c_int) :: c_spir_choose_working_type

end function

function c_spir_gauss_legendre_rule_piecewise_double( &
    & n, segments, n_segments, x, w, status) &
    bind(c, name="spir_gauss_legendre_rule_piecewise_double")
  import :: c_int, c_ptr
  integer(c_int), value :: n
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: x
  type(c_ptr), value :: w
  type(c_ptr), value :: status
  integer(c_int) :: c_spir_gauss_legendre_rule_piecewise_double

end function

function c_spir_gauss_legendre_rule_piecewise_ddouble( &
    & n, segments, n_segments, x_high, x_low, w_high, w_low, status) &
    bind(c, name="spir_gauss_legendre_rule_piecewise_ddouble")
  import :: c_int, c_ptr
  integer(c_int), value :: n
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: x_high
  type(c_ptr), value :: x_low
  type(c_ptr), value :: w_high
  type(c_ptr), value :: w_low
  type(c_ptr), value :: status
  integer(c_int) :: c_spir_gauss_legendre_rule_piecewise_ddouble

end function

