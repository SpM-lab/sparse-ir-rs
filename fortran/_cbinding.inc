! Autogenerated Fortran interfaces for ../sparse-ir-capi/include/sparseir/sparseir.h
subroutine c_spir_basis_release(basis) &
    bind(c, name="spir_basis_release")
  use iso_c_binding
  type(c_ptr), value :: basis
end subroutine

function c_spir_basis_clone(src) &
    bind(c, name="spir_basis_clone")
  use iso_c_binding
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_basis_clone
end function

function c_spir_basis_is_assigned(obj) &
    bind(c, name="spir_basis_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_basis_is_assigned
end function

function c_spir_basis_new(statistics, beta, omega_max, epsilon, k, sve, max_size, status) &
    bind(c, name="spir_basis_new")
  use iso_c_binding
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  real(c_double), value :: epsilon
  type(c_ptr), value :: k
  type(c_ptr), value :: sve
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_new
end function

function c_spir_basis_new_from_sve_and_inv_weight(statistics, beta, omega_max, epsilon, lambda, _ypower, _conv_radius, sve, inv_weight_funcs, max_size, status) &
    bind(c, name="spir_basis_new_from_sve_and_inv_weight")
  use iso_c_binding
  integer(c_int), value :: statistics
  real(c_double), value :: beta
  real(c_double), value :: omega_max
  real(c_double), value :: epsilon
  real(c_double), value :: lambda
  integer(c_int), value :: _ypower
  real(c_double), value :: _conv_radius
  type(c_ptr), value :: sve
  type(c_ptr), value :: inv_weight_funcs
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_new_from_sve_and_inv_weight
end function

function c_spir_basis_get_size(b, size) &
    bind(c, name="spir_basis_get_size")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_basis_get_size
end function

function c_spir_basis_get_svals(b, svals) &
    bind(c, name="spir_basis_get_svals")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_basis_get_svals
end function

function c_spir_basis_get_stats(b, statistics) &
    bind(c, name="spir_basis_get_stats")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: statistics
  integer(c_int) :: c_spir_basis_get_stats
end function

function c_spir_basis_get_singular_values(b, svals) &
    bind(c, name="spir_basis_get_singular_values")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_basis_get_singular_values
end function

function c_spir_basis_get_n_default_taus(b, num_points) &
    bind(c, name="spir_basis_get_n_default_taus")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_taus
end function

function c_spir_basis_get_default_taus(b, points) &
    bind(c, name="spir_basis_get_default_taus")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_taus
end function

function c_spir_basis_get_n_default_matsus(b, positive_only, num_points) &
    bind(c, name="spir_basis_get_n_default_matsus")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_matsus
end function

function c_spir_basis_get_default_matsus(b, positive_only, points) &
    bind(c, name="spir_basis_get_default_matsus")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_matsus
end function

function c_spir_basis_get_u(b, status) &
    bind(c, name="spir_basis_get_u")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_u
end function

function c_spir_basis_get_v(b, status) &
    bind(c, name="spir_basis_get_v")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_v
end function

function c_spir_basis_get_n_default_ws(b, num_points) &
    bind(c, name="spir_basis_get_n_default_ws")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_basis_get_n_default_ws
end function

function c_spir_basis_get_default_ws(b, points) &
    bind(c, name="spir_basis_get_default_ws")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_basis_get_default_ws
end function

function c_spir_basis_get_uhat(b, status) &
    bind(c, name="spir_basis_get_uhat")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_uhat
end function

function c_spir_basis_get_uhat_full(b, status) &
    bind(c, name="spir_basis_get_uhat_full")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_basis_get_uhat_full
end function

function c_spir_basis_get_default_taus_ext(b, n_points, points, n_points_returned) &
    bind(c, name="spir_basis_get_default_taus_ext")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_basis_get_default_taus_ext
end function

function c_spir_basis_get_n_default_matsus_ext(b, positive_only, L, num_points_returned) &
    bind(c, name="spir_basis_get_n_default_matsus_ext")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: L
  type(c_ptr), value :: num_points_returned
  integer(c_int) :: c_spir_basis_get_n_default_matsus_ext
end function

function c_spir_basis_get_default_matsus_ext(b, positive_only, mitigate, n_points, points, n_points_returned) &
    bind(c, name="spir_basis_get_default_matsus_ext")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: mitigate
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_basis_get_default_matsus_ext
end function

function c_spir_dlr_new(b, status) &
    bind(c, name="spir_dlr_new")
  use iso_c_binding
  type(c_ptr), value :: b
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_dlr_new
end function

function c_spir_dlr_new_with_poles(b, npoles, poles, status) &
    bind(c, name="spir_dlr_new_with_poles")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: npoles
  type(c_ptr), value :: poles
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_dlr_new_with_poles
end function

function c_spir_dlr_get_npoles(dlr, num_poles) &
    bind(c, name="spir_dlr_get_npoles")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: num_poles
  integer(c_int) :: c_spir_dlr_get_npoles
end function

function c_spir_dlr_get_poles(dlr, poles) &
    bind(c, name="spir_dlr_get_poles")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: poles
  integer(c_int) :: c_spir_dlr_get_poles
end function

function c_spir_ir2dlr_dd(dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_dd")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_ir2dlr_dd
end function

function c_spir_ir2dlr_zz(dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_ir2dlr_zz")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_ir2dlr_zz
end function

function c_spir_dlr2ir_dd(dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_dd")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_dlr2ir_dd
end function

function c_spir_dlr2ir_zz(dlr, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_dlr2ir_zz")
  use iso_c_binding
  type(c_ptr), value :: dlr
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_dlr2ir_zz
end function

subroutine c_spir_funcs_release(funcs) &
    bind(c, name="spir_funcs_release")
  use iso_c_binding
  type(c_ptr), value :: funcs
end subroutine

function c_spir_funcs_clone(src) &
    bind(c, name="spir_funcs_clone")
  use iso_c_binding
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_funcs_clone
end function

function c_spir_funcs_is_assigned(obj) &
    bind(c, name="spir_funcs_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_funcs_is_assigned
end function

function c_spir_funcs_from_piecewise_legendre(segments, n_segments, coeffs, nfuncs, _order, status) &
    bind(c, name="spir_funcs_from_piecewise_legendre")
  use iso_c_binding
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: coeffs
  integer(c_int), value :: nfuncs
  integer(c_int), value :: _order
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_funcs_from_piecewise_legendre
end function

function c_spir_funcs_get_slice(funcs, nslice, indices, status) &
    bind(c, name="spir_funcs_get_slice")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: nslice
  type(c_ptr), value :: indices
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_funcs_get_slice
end function

function c_spir_funcs_get_size(funcs, size) &
    bind(c, name="spir_funcs_get_size")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_funcs_get_size
end function

function c_spir_funcs_get_n_knots(funcs, n_knots) &
    bind(c, name="spir_funcs_get_n_knots")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: n_knots
  integer(c_int) :: c_spir_funcs_get_n_knots
end function

function c_spir_funcs_get_knots(funcs, knots) &
    bind(c, name="spir_funcs_get_knots")
  use iso_c_binding
  type(c_ptr), value :: funcs
  type(c_ptr), value :: knots
  integer(c_int) :: c_spir_funcs_get_knots
end function

function c_spir_funcs_eval(funcs, x, out) &
    bind(c, name="spir_funcs_eval")
  use iso_c_binding
  type(c_ptr), value :: funcs
  real(c_double), value :: x
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_eval
end function

function c_spir_funcs_eval_matsu(funcs, n, out) &
    bind(c, name="spir_funcs_eval_matsu")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: n
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_eval_matsu
end function

function c_spir_funcs_batch_eval(funcs, order, num_points, xs, out) &
    bind(c, name="spir_funcs_batch_eval")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_points
  type(c_ptr), value :: xs
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_batch_eval
end function

function c_spir_funcs_batch_eval_matsu(funcs, order, num_freqs, ns, out) &
    bind(c, name="spir_funcs_batch_eval_matsu")
  use iso_c_binding
  type(c_ptr), value :: funcs
  integer(c_int), value :: order
  integer(c_int), value :: num_freqs
  type(c_ptr), value :: ns
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_funcs_batch_eval_matsu
end function

function c_spir_uhat_get_default_matsus(uhat, l, positive_only, mitigate, points, n_points_returned) &
    bind(c, name="spir_uhat_get_default_matsus")
  use iso_c_binding
  type(c_ptr), value :: uhat
  integer(c_int), value :: l
  integer(c_int), value :: positive_only
  integer(c_int), value :: mitigate
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points_returned
  integer(c_int) :: c_spir_uhat_get_default_matsus
end function

function c_spir_gemm_backend_new_from_fblas_lp64(dgemm, zgemm) &
    bind(c, name="spir_gemm_backend_new_from_fblas_lp64")
  use iso_c_binding
  type(c_ptr), value :: dgemm
  type(c_ptr), value :: zgemm
  type(c_ptr) :: c_spir_gemm_backend_new_from_fblas_lp64
end function

function c_spir_gemm_backend_new_from_fblas_ilp64(dgemm64, zgemm64) &
    bind(c, name="spir_gemm_backend_new_from_fblas_ilp64")
  use iso_c_binding
  type(c_ptr), value :: dgemm64
  type(c_ptr), value :: zgemm64
  type(c_ptr) :: c_spir_gemm_backend_new_from_fblas_ilp64
end function

subroutine c_spir_gemm_backend_release(backend) &
    bind(c, name="spir_gemm_backend_release")
  use iso_c_binding
  type(c_ptr), value :: backend
end subroutine

function c_spir_logistic_kernel_new(lambda, status) &
    bind(c, name="spir_logistic_kernel_new")
  use iso_c_binding
  real(c_double), value :: lambda
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_logistic_kernel_new
end function

function c_spir_reg_bose_kernel_new(lambda, status) &
    bind(c, name="spir_reg_bose_kernel_new")
  use iso_c_binding
  real(c_double), value :: lambda
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_reg_bose_kernel_new
end function

function c_spir_kernel_get_lambda(kernel, lambda_out) &
    bind(c, name="spir_kernel_get_lambda")
  use iso_c_binding
  type(c_ptr), value :: kernel
  type(c_ptr), value :: lambda_out
  integer(c_int) :: c_spir_kernel_get_lambda
end function

function c_spir_kernel_compute(kernel, x, y, out) &
    bind(c, name="spir_kernel_compute")
  use iso_c_binding
  type(c_ptr), value :: kernel
  real(c_double), value :: x
  real(c_double), value :: y
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_kernel_compute
end function

subroutine c_spir_kernel_release(kernel) &
    bind(c, name="spir_kernel_release")
  use iso_c_binding
  type(c_ptr), value :: kernel
end subroutine

function c_spir_kernel_clone(src) &
    bind(c, name="spir_kernel_clone")
  use iso_c_binding
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_kernel_clone
end function

function c_spir_kernel_is_assigned(obj) &
    bind(c, name="spir_kernel_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_kernel_is_assigned
end function

function c_spir_kernel_get_domain(k, xmin, xmax, ymin, ymax) &
    bind(c, name="spir_kernel_get_domain")
  use iso_c_binding
  type(c_ptr), value :: k
  type(c_ptr), value :: xmin
  type(c_ptr), value :: xmax
  type(c_ptr), value :: ymin
  type(c_ptr), value :: ymax
  integer(c_int) :: c_spir_kernel_get_domain
end function

function c_spir_kernel_get_sve_hints_segments_x(k, epsilon, segments, n_segments) &
    bind(c, name="spir_kernel_get_sve_hints_segments_x")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: segments
  type(c_ptr), value :: n_segments
  integer(c_int) :: c_spir_kernel_get_sve_hints_segments_x
end function

function c_spir_kernel_get_sve_hints_segments_y(k, epsilon, segments, n_segments) &
    bind(c, name="spir_kernel_get_sve_hints_segments_y")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: segments
  type(c_ptr), value :: n_segments
  integer(c_int) :: c_spir_kernel_get_sve_hints_segments_y
end function

function c_spir_kernel_get_sve_hints_nsvals(k, epsilon, nsvals) &
    bind(c, name="spir_kernel_get_sve_hints_nsvals")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: nsvals
  integer(c_int) :: c_spir_kernel_get_sve_hints_nsvals
end function

function c_spir_kernel_get_sve_hints_ngauss(k, epsilon, ngauss) &
    bind(c, name="spir_kernel_get_sve_hints_ngauss")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  type(c_ptr), value :: ngauss
  integer(c_int) :: c_spir_kernel_get_sve_hints_ngauss
end function

subroutine c_spir_sampling_release(sampling) &
    bind(c, name="spir_sampling_release")
  use iso_c_binding
  type(c_ptr), value :: sampling
end subroutine

function c_spir_sampling_clone(src) &
    bind(c, name="spir_sampling_clone")
  use iso_c_binding
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_sampling_clone
end function

function c_spir_sampling_is_assigned(obj) &
    bind(c, name="spir_sampling_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_sampling_is_assigned
end function

function c_spir_tau_sampling_new(b, num_points, points, status) &
    bind(c, name="spir_tau_sampling_new")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_tau_sampling_new
end function

function c_spir_matsu_sampling_new(b, positive_only, num_points, points, status) &
    bind(c, name="spir_matsu_sampling_new")
  use iso_c_binding
  type(c_ptr), value :: b
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_matsu_sampling_new
end function

function c_spir_tau_sampling_new_with_matrix(order, statistics, basis_size, num_points, points, matrix, status) &
    bind(c, name="spir_tau_sampling_new_with_matrix")
  use iso_c_binding
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_tau_sampling_new_with_matrix
end function

function c_spir_matsu_sampling_new_with_matrix(order, statistics, basis_size, positive_only, num_points, points, matrix, status) &
    bind(c, name="spir_matsu_sampling_new_with_matrix")
  use iso_c_binding
  integer(c_int), value :: order
  integer(c_int), value :: statistics
  integer(c_int), value :: basis_size
  integer(c_int), value :: positive_only
  integer(c_int), value :: num_points
  type(c_ptr), value :: points
  type(c_ptr), value :: matrix
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_matsu_sampling_new_with_matrix
end function

function c_spir_sampling_get_npoints(s, num_points) &
    bind(c, name="spir_sampling_get_npoints")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: num_points
  integer(c_int) :: c_spir_sampling_get_npoints
end function

function c_spir_sampling_get_taus(s, points) &
    bind(c, name="spir_sampling_get_taus")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_sampling_get_taus
end function

function c_spir_sampling_get_matsus(s, points) &
    bind(c, name="spir_sampling_get_matsus")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: points
  integer(c_int) :: c_spir_sampling_get_matsus
end function

function c_spir_sampling_get_cond_num(s, cond_num) &
    bind(c, name="spir_sampling_get_cond_num")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: cond_num
  integer(c_int) :: c_spir_sampling_get_cond_num
end function

function c_spir_sampling_eval_dd(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dd")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_dd
end function

function c_spir_sampling_eval_dz(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_dz")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_dz
end function

function c_spir_sampling_eval_zz(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_eval_zz")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_eval_zz
end function

function c_spir_sampling_fit_dd(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_dd")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_dd
end function

function c_spir_sampling_fit_zz(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_zz")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_zz
end function

function c_spir_sampling_fit_zd(s, backend, order, ndim, input_dims, target_dim, input, out) &
    bind(c, name="spir_sampling_fit_zd")
  use iso_c_binding
  type(c_ptr), value :: s
  type(c_ptr), value :: backend
  integer(c_int), value :: order
  integer(c_int), value :: ndim
  type(c_ptr), value :: input_dims
  integer(c_int), value :: target_dim
  type(c_ptr), value :: input
  type(c_ptr), value :: out
  integer(c_int) :: c_spir_sampling_fit_zd
end function

subroutine c_spir_sve_result_release(sve) &
    bind(c, name="spir_sve_result_release")
  use iso_c_binding
  type(c_ptr), value :: sve
end subroutine

function c_spir_sve_result_clone(src) &
    bind(c, name="spir_sve_result_clone")
  use iso_c_binding
  type(c_ptr), value :: src
  type(c_ptr) :: c_spir_sve_result_clone
end function

function c_spir_sve_result_is_assigned(obj) &
    bind(c, name="spir_sve_result_is_assigned")
  use iso_c_binding
  type(c_ptr), value :: obj
  integer(c_int) :: c_spir_sve_result_is_assigned
end function

function c_spir_sve_result_new(k, epsilon, _lmax, _n_gauss, twork, status) &
    bind(c, name="spir_sve_result_new")
  use iso_c_binding
  type(c_ptr), value :: k
  real(c_double), value :: epsilon
  integer(c_int), value :: _lmax
  integer(c_int), value :: _n_gauss
  integer(c_int), value :: twork
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_new
end function

function c_spir_sve_result_get_size(sve, size) &
    bind(c, name="spir_sve_result_get_size")
  use iso_c_binding
  type(c_ptr), value :: sve
  type(c_ptr), value :: size
  integer(c_int) :: c_spir_sve_result_get_size
end function

function c_spir_sve_result_truncate(sve, epsilon, max_size, status) &
    bind(c, name="spir_sve_result_truncate")
  use iso_c_binding
  type(c_ptr), value :: sve
  real(c_double), value :: epsilon
  integer(c_int), value :: max_size
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_truncate
end function

function c_spir_sve_result_get_svals(sve, svals) &
    bind(c, name="spir_sve_result_get_svals")
  use iso_c_binding
  type(c_ptr), value :: sve
  type(c_ptr), value :: svals
  integer(c_int) :: c_spir_sve_result_get_svals
end function

function c_spir_sve_result_from_matrix(K_high, K_low, nx, ny, order, segments_x, n_segments_x, segments_y, n_segments_y, n_gauss, epsilon, status) &
    bind(c, name="spir_sve_result_from_matrix")
  use iso_c_binding
  type(c_ptr), value :: K_high
  type(c_ptr), value :: K_low
  integer(c_int), value :: nx
  integer(c_int), value :: ny
  integer(c_int), value :: order
  type(c_ptr), value :: segments_x
  integer(c_int), value :: n_segments_x
  type(c_ptr), value :: segments_y
  integer(c_int), value :: n_segments_y
  integer(c_int), value :: n_gauss
  real(c_double), value :: epsilon
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_from_matrix
end function

function c_spir_sve_result_from_matrix_centrosymmetric(K_even_high, K_even_low, K_odd_high, K_odd_low, nx, ny, order, segments_x, n_segments_x, segments_y, n_segments_y, n_gauss, epsilon, status) &
    bind(c, name="spir_sve_result_from_matrix_centrosymmetric")
  use iso_c_binding
  type(c_ptr), value :: K_even_high
  type(c_ptr), value :: K_even_low
  type(c_ptr), value :: K_odd_high
  type(c_ptr), value :: K_odd_low
  integer(c_int), value :: nx
  integer(c_int), value :: ny
  integer(c_int), value :: order
  type(c_ptr), value :: segments_x
  integer(c_int), value :: n_segments_x
  type(c_ptr), value :: segments_y
  integer(c_int), value :: n_segments_y
  integer(c_int), value :: n_gauss
  real(c_double), value :: epsilon
  type(c_ptr), value :: status
  type(c_ptr) :: c_spir_sve_result_from_matrix_centrosymmetric
end function

function c_spir_choose_working_type(epsilon) &
    bind(c, name="spir_choose_working_type")
  use iso_c_binding
  real(c_double), value :: epsilon
  integer(c_int) :: c_spir_choose_working_type
end function

function c_spir_gauss_legendre_rule_piecewise_double(n, segments, n_segments, x, w, status) &
    bind(c, name="spir_gauss_legendre_rule_piecewise_double")
  use iso_c_binding
  integer(c_int), value :: n
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: x
  type(c_ptr), value :: w
  type(c_ptr), value :: status
  integer(c_int) :: c_spir_gauss_legendre_rule_piecewise_double
end function

function c_spir_gauss_legendre_rule_piecewise_ddouble(n, segments, n_segments, x_high, x_low, w_high, w_low, status) &
    bind(c, name="spir_gauss_legendre_rule_piecewise_ddouble")
  use iso_c_binding
  integer(c_int), value :: n
  type(c_ptr), value :: segments
  integer(c_int), value :: n_segments
  type(c_ptr), value :: x_high
  type(c_ptr), value :: x_low
  type(c_ptr), value :: w_high
  type(c_ptr), value :: w_low
  type(c_ptr), value :: status
  integer(c_int) :: c_spir_gauss_legendre_rule_piecewise_ddouble
end function

